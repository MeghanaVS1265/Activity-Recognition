# -*- coding: utf-8 -*-
"""videoHAR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bXDw34YrvrlrZtAef6DQJDT0xvBMSH2j
"""

import os
os.environ["CUDA_DEVICE_ORDER"]="PCI_BUS_ID";  # The GPU id to use, usually either "0" or "1";
os.environ["CUDA_VISIBLE_DEVICES"]="0";  # Do other imports now...

import tensorflow as tf

# Need to specify the memory_limit for my local machine for some reason, but didn't seem to be required
# on AWS machine
gpus = tf.config.experimental.list_physical_devices('GPU')

print(gpus)
tf.config.experimental.set_virtual_device_configuration(gpus[0], [tf.config.experimental.VirtualDeviceConfiguration(memory_limit=23400)])

# Check tensorflow version
print("Using Tensorflow %s\n" % (tf.__version__))

from tensorflow.keras.models import load_model
from collections import deque
import numpy as np
import cv2
from tensorflow.keras.models import Model


from tensorflow.keras.applications.inception_resnet_v2 import InceptionResNetV2, preprocess_input

model =load_model('/content/drive/MyDrive/CV project/models/class_only/15_epochs.h5')
model.summary()

pixels = model.input.get_shape().as_list()[1]
pixels

import json

# Read mapping file from  class index -> activity
with open("/content/drive/MyDrive/CV project/classes.json") as fp:
    mapping = json.loads(fp.read())

# Convert keys back to integer
mapping = {int(k):v for k,v in mapping.items()}

# Print out first 10 entries of mapping dictionary
for i in list(mapping)[0:10]:
    print (f"{i} : {mapping[i]}")

from tensorflow.keras.applications.inception_resnet_v2 import InceptionResNetV2, preprocess_input

def predict(image_data, model):
    
    processed_input = preprocess_input(image_data)
    
    # Run model's prediction to output from last Conv Layer + category prediction
    pred_vec = model.predict(processed_input)
    
    predictions = []
    for i in range(pred_vec.shape[0]):
        predictions.append(pred_vec[i])
        
    return predictions

def predict_video(filename, k = 200):
    vs = cv2.VideoCapture(filename)

    (W, H) = (None, None)

    count = 0


    image_data = np.zeros((k, pixels, pixels, 3))

    all_predictions = []


    while True:
        
        (grabbed, frame) = vs.read()
        
        if not grabbed:
            break

        if W is None or H is None:
            (H, W) = frame.shape[:2]

        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        frame = cv2.resize(frame, (pixels, pixels)).astype("float32")
      
        
        image_data[count] = frame

        count = count + 1    
        
        if count == k:
            predictions = predict(image_data, model)
            all_predictions.extend(predictions)
            count = 0
                
    if count > 0:
        predictions = predict(image_data[:count], model)
        all_predictions.extend(predictions)
        

    vs.release()
    cv2.destroyAllWindows()

    averaged = np.mean(all_predictions, axis= 0)
    activity = mapping[np.argmax(averaged)]
    
    top_5_idx = np.argsort(averaged)[-5:]
    top_5 = [mapping[idx] for idx in top_5_idx]

    for prediction in all_predictions:
        del prediction
    
    return activity, top_5

activity,top_five = predict_video("/content/drive/MyDrive/CV project/test_videos/applauding/0nd-Gc3HkmU_19_10.mp4")
top_five

import os
import json

correct = dict()
in_top_5 = dict()
incorrect = dict()

count = 0
import gc
gc.collect()

for root, dirs, files in os.walk("/content/drive/MyDrive/CV project/test_videos"):
    for file in files:
        if file.endswith(".mp4"):
            orig_category = os.path.basename(root).replace(" ", "_")
            category = orig_category                
            prediction, top_5 = predict_video(os.path.join(root, file))
            
            if prediction == category:
                correct[os.path.join(orig_category, file)] = prediction
                print(f"correct: {os.path.join(orig_category, file)} => {prediction}")
            else:
                if category in top_5:
                    in_top_5[os.path.join(orig_category, file)] = top_5
                    print(f"in top 5: {os.path.join(orig_category, file)} => {top_5}")
                else:
                    incorrect[os.path.join(orig_category, file)] = prediction    
                    print(f"wrong: {os.path.join(orig_category, file)} => {prediction}")
                    
            count += 1
            
            if count % 20 == 0:
                gc.collect()

corr = len(correct)
top = len(in_top_5)
inc = len(incorrect)
total = corr + top + inc
corr_acc = corr/total*100
top_5_acc = top/total*100

print("Classification Accuracy")
print("-----------------------")
print("Accuracy is:   {0:.2f} %".format(corr_acc))

print("Top 5 acc is:  {0:.2f} %".format(top_5_acc))

